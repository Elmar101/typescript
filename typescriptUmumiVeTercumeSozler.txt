*******************************************************************************************************************

literal  - kelmesi kelmesine, aynisi, herfi => yeni name = name - herfi uyqunluq
specify  - dəqiqləşdirmək, yəqinləşdirmək, belirtmek
known    - bilinen, taninan ,məlum, bəlli
unions   - bitlikler

Discriminated  - Ayrı-seçkilik,fərqli əlamətlərə malik olmaq, fərq qoymaq,ayrı tutmak,farklı muamele etmek

assignable - təyin edilə bilən, atanabilir, verilebilir

is not assignable - təyin edilə bilməz ,atanamaz

x does not exist in type X - X tipinde x mevcut değildir.

*******************************************************************************************************************

=> void funuksia geriye nese qaytarmir eger qaytarsada undefined qaytarir !!
!* let x = function myFn():void{ console.log("qaqa x in deyeri undefined-dir") } => x == undefined - true 

*******************************************************************************************************************

=> type  union - type x = string | number | boolean | string[] | number[] 
type MyBool = true | false;
type WindowStates = "open" | "closed" | "minimized";
type LockStates = "locked" | "unlocked";
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
function getLength(p1: string | string[]):number { return p1.length; }
union - birlik,mutefik
Type Aliases - Tür Takma Adlar
Interfaces - Arayüzler
Assertion - iddia, hakkinda arama
Enums     -   Numaralandırmalar
Narrowing - daraltma2
typeof - tip muhafızlar
*******************************************************************************************************************

Bir dəğişkənin tipini öğrənmək üçün - typeof - Bu kəlmədən istifadə edirik 
string	  |   typeof s === "string"
number    |   typeof n === "number"
boolean	  |   typeof b === "boolean"
undefined |	  typeof undefined === "undefined"
function  |   typeof f === "function"
array	  |   Array.isArray(a)

*******************************************************************************************************************

Non-null Assertion Operator (Postfix!) - Null Olmayan Onaylama Operatörü (Sonek!)

*******************************************************************************************************************
JavaScript'te if - in false olduqu durumlar => 0 , ""  (boş string), undefined , null, NaN
yoxlamaq Üçün - Boolean(data) - BU METODLA YOXLAYA BİLERSİZ !!!
console.log( "BOŞ STRİNG - " ,  Boolean("") );// false
console.log( "SİFR STRİNG - " , Boolean(0) );// false
console.log( "NaN - " ,         Boolean(NaN) );// false
console.log( "Null - " ,        Boolean(null) );// false
console.log( "UNDEFİNED - " ,   Boolean(undefined) );// false
console.log( "ARRAY - " ,       Boolean([].length )); // false   //ARRAYIN YOXLANMASI
const objCheck = {};
console.log( "OBJECT - " ,      Boolean(Object.entries(objCheck).length )) ; //false // OBJECTIN YOXLANMASI

UNUDMA !!!
Boolean("hello"); // true
Boolean(1); // true
Boolean([]); // true
Boolean({}) ; // true

**************************************************************************************************************
=> in operatöru ile Objecti yoxlamaq => property adi varmi => if(propertyAd in ObjectAd) vars trur yoxsa false
type Fish = { swim: () => void };
type Bird = { fly: () => void };
type Human = { swim?: () => void; fly?: () => void };
 
function move(animal: Fish | Bird | Human) {
  if ("swim" in animal) { animal; =>(parameter) animal: Fish | Human } 
  else { animal; => (parameter) animal: Bird | Human }
}

let baliq: Fish = { swim(){ console.log('i am baliq')} }// Bele yazlişdan daha çox istifadə edilir !!!
move(baliq);  => i am baliq

let qush: Bird = { fly: ()=> { console.log('i am qush')} }
move(qush); => i am qush


****************************************************************************************************************

=> instanceof ile yoxlamaq 

function logValue(x: Date | string) {
  if (x instanceof Date) { console.log(x.toUTCString());     (parameter) x: Date } 
  else { console.log(x.toUpperCase()); (parameter) x: string }
}

logValue("Hello str"); => HELLO STR
logValue( new Date() ); => Fri, 08 Oct 2021 13:43:55 GMT

*****************************************************************************************************************

=> Assignments - Atamalar => TypeScript, atamanın sağ tarafına bakar ve sol tarafı uygun şekilde bize qaytarar
- random olaraq Math.random() qiymet alir ve hemin qiymete gore  r in tipi melum olur r ya 10 yada hello world olur 
=>r =  10  r in tipi  number OR r =  hello world!  r in tipi  string

let r: string | number = Math.random() < 0.5 ? 10 : "hello world!";
console.log("r = ", r , " r in tipi ", typeof r);  

******************************************************************************************************************
=> Using type predicates - Tip predikatlarından istifadə
=> parameterName is Type => pet is Fish = boolean

type Fishs = { swim: () => void };
type Birds = { fly: () => void };

function isFish(pet: Fishs | Birds): pet is Fish { 
    pet is Fish =>return boolean qaytarmasidi yeni funuksia tru yada false qaytaracaq 
    return bize true yaxud false qaytarir

    return (pet as Fish).swim !== undefined;
}

let baliqlar: Fishs = { swim(){ console.log('i am baliq')} }
let isfish = isFish(baliqlar);
console.log("baliqdirmi:", isfish);//true

let qushlar: Bird = { fly:()=> { console.log('i am qush')} }
    isfish = isFish(qushlar);
    console.log("baliqdirmi:", isfish);//false



*******************************************************************************************************************
=> Discriminated unions - Ayrımcı birlikler
=> ! - shape.radius! -> shapede radius -un kesinlikle mevcut olduğunu söylemek için boş olmayan bir iddia
interface Shape {
    kind: "circle" | "square";
    radius?: number;
    sideLength?: number;
}

function handleShape(shape: Shape) {

    if (shape.kind === "circle") {
        return "circle";
    }
    else return "square";
}

function getArea(shape: Shape) {
    return Math.PI * shape.radius! ** 2;
}

2 ci yol discriminated unions switch ile

interface Circle {
    kind: "circle";
    radius: number;
  }
   
  interface Square {
    kind: "square";
    sideLength: number;
  }
   
  type Shape = Circle | Square;

  function getArea2(shape: Shape) {
    switch (shape.kind) {
        case "circle" :  return Math.PI * shape.radius ** 2 ; break;
        case "square" :  return Math.PI * shape.sideLength **2 ; break
    }
  }



******************************************************************************************************************
=> Exhaustiveness checking - Kapsamlılık kontrolü (never)
- neverTürü, her tür tayin edilebilir; ancak, hiçbir tür atanamaz never( neverkendisi dışında ). 
  Bu, daraltmayı kullanabileceğiniz ve neverbir switch ifadesinde kapsamlı kontrol yapmak için 
  açmaya güvenebileceğiniz anlamına gelir .
  Örneğin, bir ekleme default bizim için getAreaşekil atamak çalışır 
  fonksiyonu nevermümkün olan her durumda ele alınmayınca irade zam.

interface Circle {
    kind: "circle";
    radius: number;
  }
   
  interface Square {
    kind: "square";
    sideLength: number;
  }
type Shape = Circle | Square;
 
function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}

indi yeni bir tip elave edek never hemen error verecek çünki never heç bir tip olmayanda default qaytarir

interface Triangle {
  kind: "triangle";
  sideLength: number;
}

type Shape = Circle | Square | Triangle

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      const _exhaustiveCheck: never = shape;  => burada error bash verecek 3 ci case yazmamisiq die
      return _exhaustiveCheck;
  }
}

- asaqidaki sekilde olmalidi !!!!

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;

    case "square":
      return shape.sideLength ** 2;

    case "triangle":
      return Math.PI * shape.sideLength ** 2;

    default:
      const _exhaustiveCheck: never = shape;  => burada error bash verecek 3 ci case yazmamisiq die
      return _exhaustiveCheck;
  }
}
 
**************************************************************************************************************
=> Function Type Expressions

function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}
 
function printToConsole(s: string) {
  console.log(s);
}
 
greeter(printToConsole);